#             面经笔记

## Java

### 1.集合：

#### 1.1 说说List，Set，Queue，Map四者的区别？

```
List：存储的元素是有序的，可重复的。
Set：存储的元素是不可重复的。
Queue：按特定的排队跪着来确定先后顺序，存储的元素是有序的，可重复的。
Map：使用键值对存储，key是无序，不可重复的，value是无序，可重复的。
```

#### 2.1 为什么要用集合？

```
集合的优势在于其的大小可变，支持泛型，具有内建算法，提高了数据的存储和处理灵活性。
```



| 类型          | 容量 | 扩容策略 | 备注                                                     |
| ------------- | :--: | -------- | -------------------------------------------------------- |
| ArrayList     |  10  | 1.5倍    | 数组                                                     |
| Vector        |  10  | 2倍      | 数组                                                     |
| HashSet       |  16  | 2倍      | 基于HashMap实现                                          |
| LinkedList    |  无  | 无       | 双向链表                                                 |
| HashMap       |  16  | 2倍      | 链表＋数组+红黑树，当链表长度超过8（默认）时，转为红黑树 |
| LinkedHashMap |  16  | 2倍      | 链表＋数组+红黑树                                        |
| HashTable     |  11  | 2n+1     | 数组＋链表                                               |
| LinkedHashSet |  16  | 2倍      | 内部通过LinkedHashMap来实现                              |

### 2.并发编程

#### 2.1 如何创建线程

```
继承Thread类，实现Runnable接口，实现Callable接口，使用线程池，使用CompletableFuture类等。
```

#### 2.2 如何理解线程安全和不安全

```
线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。
·线程安全：指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问都能保证其的正确性和一致性。
·线程不安全：指的是在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱，错误或者丢失。
```

#### 2.3 sleep()方法和wait()方法对比

```
共同点：两者都可以暂停线程的执行。
区别：
·sleep()方法没有释放锁，而wait()方法释放了锁。
·wait()通常被用于线程间交互/通信,sleep()方法通常被用于暂停执行。
·wait()方法完成后，线程不会自动苏醒，sleep()方法执行完成后，线程会自动苏醒。
·sleep()方法是Thread类的静态本地方法，wait()是Object类的本地方法。
```

#### 2.4 什么是乐观锁和悲观锁

```
乐观锁：总是假设最好情况，认为共享资源每次被访问时不会出现问题，线程可以不停执行，无需加锁和等待，只在提交修改时候，验证对应的资源是否被其他线程修改，可用CAS（Compare And Swap）算法实现，存在ABA问题，解决思路：加上版本号或时间戳。
悲观锁：总是假设最坏情况，认为共享资源每次被访问时都会出现问题，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。
```

#### 2.5 什么是公平锁和非公平锁

```
公平锁：锁被释放后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换频繁。
非公平锁：锁被释放后，后申请的线程可能先得到锁，是随机或者按照其他优先级排序的，性能更好，但可能导致某些线程永远无法获取到锁。
```

#### 2.6 synchronized是什么？有什么用？如何使用？

```
synchronized是Java中的一个关键字，翻译为同步，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。
synchronized关键字的使用方式主要有下面3种：
1.修饰实例方法
2.修饰静态方法
3.修饰代码块
```

#### 2.7 如何创建线程池

```
1.通过ThreadPoolExecutor构造函数来创建（推荐）。
2.通过Executor框架的工具类Executors来创建。
```

### 3.基础

#### 3.1 String，StringBuffer，StringBuilder的区别？

```
String中的对象是不可变的，线程安全，而StringBuffer和StringBuilder均继承了AbstractStringBuilder，定义了一些对字符串的基本操作，其中StringBuffer对方法添加了同步锁或者对调用的方法加了同步锁，因此也是线程安全的，而StringBuilder没有对方法加锁，因此线程不安全。
每次对String类型进行改变时，都会产生一个新的String对象，然后将指针指向String对象，而StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变引用。
```

#### 3.2 字符串常量池的作用？

```
字符串常量池是JVM为了提升性能和减少内存消耗，针对字符串专门开辟的一块区域，主要目的是为了避免字符串的重复创建。
```

#### 3.3 Stirng s = new String（“abc”）这句话创建了几个字符串对象？

```
会创建1或2个字符串对象
1.如果字符串常量池中不存在字符串对象的引用，那么会在堆上创建两个字符串对象，其中一个字符串的引用会被保存在字符串常量池中。
2.如果字符串常量池中已经存在，则只会在堆中创建一个字符串对象。
```

#### 3.4 什么是注解？

```
Annotation（注解）是Java5开始引入的新特性，可以看作一种特殊的注释，主要用于修饰类，方法或者变量，提供某些信息供程序在编译或者运行时使用
```

#### 3.5 注解的解析方法有哪几种？

```
编译期直接扫描；运行期通过反射处理。
```

#### 3.6 访问控制符

<img src="https://uploadfiles.nowcoder.com/images/20201020/267991864_1603185293155_E79A24FF06B5AC9E726A775B1C9F8FE9" alt="img" style="zoom:200%;" />

### 4.IO

#### 4.1 IO流的分类？

```
字符流（Reader，Writer）和字节流（InputStream，OutputStream）
```

#### 4.2 Java中三种常见的IO模型

```
1.BIO（同步阻塞IO模型）
2.NIO（I/O多路复用模型，或者同步非阻塞IO模型）
3.AIO（异步IO模型）
```

### 5. JVM

#### 5.1 内存区域？

![img](https://uploadfiles.nowcoder.com/images/20210910/506129651_1631265426564/272084FEBFF2E659FA20DF7ACF52DD13)

#### .2 垃圾回收？

```
JVM的垃圾回收（GC）是Java语言的一个显著特点。JVM会自动管理内存，回收不再使用的对象，释放内存空间。
主要涉及以下几个方面：
1.垃圾收集算法：标记-清除，标记-压缩，分代收集等。
2.垃圾收集器：Serial，Parallel（JDK1.8默认的收集器），CMS，G1（JDK1.9默认的收集器）等，它们是JVM的组成部分，负责实际的了垃圾收集工作。
3.内存分配和回收策略：如何分配内存给新对象，何时回收不再使用的对象。
```



## Sping&SpringBoot

### 1.什么是IOC?为什么采用IOC？

```
IOC即控制反转，它是一种思想不是一个技术实现。
什么是控制反转？
控制：对象创建（实例化，管理）的权力
反转：将控制权交给外部环境（IOC容器）
IOC的好处：1.对象之间的耦合度降低。2.资源变得容易管理
```

### 2.什么是AOP？为什么采用AOP？

```
AOP即面向切面编程，是OOP（面向对象编程）的一种延续，二者互补。
AOP的核心思想就是将横切关注点从核心业务逻辑中分离出来，形成一个个的切面。
AOP的好处：可以将横切关注点从核心业务逻辑中分离出来，实现关注点的分离
```

### 3.AOP的实现方式？

```
常见的有动态代理，字节码操作等。
```

### 4.什么是事务？

```
事务是逻辑上的一组操作，要么都执行，要么都不执行
```

### 5.事务的特性ACID？

```
1.原子性（Atomicity）:事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全执行，要么全不执行。
2.一致性（Consistency）：执行事务前后，数据保持一致。
3.隔离性（Isolation）：并发访问数据库时，用户的事务之间互不干扰，各事务之间数据库是独立的。
4.持久性（Durability）：一个事务提交后，它对数据库中数据的改变是持久的，不会因为数据库重启等受到影响。
PS：只有保证了事务的原子性，隔离性，持久性后，才能保证事务的一致性，也就是A，I，D是手段，而C目的。
```

### 6.Spring支持哪两种方式的事务管理？

```
1.编程式事务管理：通过TransactionTemplate或者TransactionManager手动管理事务。
2.声明式事务管理：实际是通过AOP实现（基于@Transactional的全注解方式使用最多）。
```

### 7.SpringBoot自动装配原理？

```
何为自动装配：通过注解或者一些简单的配置就能在SpringBoot的帮助下实现某块功能。
SpringBoot如何实现自动装配：SpringBoot通过@EnableAutoConfiguration开启自动装配，通过SpringFactoriesLoader最终加载META-INF/Spring.factories中的自动配置类实现自动装配，自动装配类其实就是通过@Conditional按需加载的配置类。
```

### 8.什么是SpringBean？

```
简单来说，Bean代指的就是被IOC容器所管理的对象。
```



## Redis

### 1.为什么采用Redis？

```
1.Redis具有高性能
2.Redis具有高并发
```

### 2.Redis的数据结构

```
String(字符串),Hash(哈希),List(列表),Set(集合),Zset(有序集合)
新增的四种：BitMap,HyperLogLog,GEO,Stream
```

### 3.Redis持久化

```
1.AOF日志：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件中。
2.RDB快照：将某一时刻的内存数据，以二进制的方式写入磁盘
3.混合持久化方式：Redis4.0新增的方式，集成了AOF和RDB的优点
```

### 4.Redis如何实现服务高可用

```
主从复制，哨兵模式，切片集群
```

### 5.Redis使用的过期删除策略

```
惰性删除+定期删除
```

### 6.Redis缓存设计

#### 6.1.缓存雪崩

***什么是缓存雪崩***：当大量缓存数据在同一时间过期(失效)时，如果此时有大量的用户请求，都无法在Redis中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃
***如何避免***：1.将缓存失效时间随机打散，2.设置缓存不过期

#### 6.2.缓存击穿

***什么是缓存击穿***：如果缓存中的某个热点数据过期了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易被高并发的请求冲垮

***如何避免***：1.互斥锁方案，2.不给热点数据设置过期时间，仅设置逻辑过期

#### 6.3.缓存穿透

***什么是缓存穿透：***当用户访问的数据，既不在缓存中，也不在数据库中，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据来服务后续的请求，当这样的请求大量到来时，数据库的压力骤增。

***如何避免：***1.非法请求的限制，2.设置空值或者默认值，3.使用布隆过滤器

### 7.常见的缓存更新策略

#### 7.1.Cache Aside策略

Cache Aside(旁路缓存)策略，分为读策略和写策略。

写策略：先更新数据库中的数据，再删除缓存中的数据

读策略：如果读取的数据命中了缓存，直接返回数据，如果没有命中，从数据库中读取数据，先写入缓存，并返回给用户

#### 7.2.Read/Write Through策略

Read/Write Through(读穿/写穿)策略。

Read Though：先查询缓存中数据是否存在，如果存在直接返回，不存在则由缓存组件从数据库中查询数据，将结果写入缓存组件，最后将缓存组件返回给应用

Write Though：当有数据更新的时候，先查询要写入的数据再缓存中是否已经存在：

​	**·**如果存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，然后缓存组件告知应用更新完成

​	**·**如果不存在，直接更新数据库，然后返回

#### 7.3.Write Back策略

Write Back(写回)策略，在更新数据时，只更新缓存，同时将缓存数据设为脏的，然后里面返回，并不会更新数据库。对于数据库的更新，会通过批量异步更新的方式进行。

## MySQL

### 1.什么是MySQL？它的优点是？

```
MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。
优点：
1.成熟稳定，功能完善。
2.开源免费。
3.文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。
4.开箱即用，操作简单，维护成本低。
5.兼容性好，支持常见的操作系统，支持多种开发语言。
6.社区活跃，生态完善。
7.支持分库分表、读写分离、高可用。
```

### 2.MySQL的数据类型：

<img src="https://oss.javaguide.cn/github/javaguide/mysql/summary-of-mysql-field-types.png" alt="MySQL 常见字段类型总结" style="zoom: 33%;" />

### 3.索引

#### 3.1 索引失效：

![image-20240614160142090](C:\Users\陈JY\AppData\Roaming\Typora\typora-user-images\image-20240614160142090.png)





## RabbitMQ

### 消息可靠性保证

#### 1.生产者：

生产者重连，生产者确认

#### 2.消费者：

消费者确认，失败重试

#### 3.MQ：

数据持久化，LazyQueue 